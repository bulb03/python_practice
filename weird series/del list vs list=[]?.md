**如題，del list到底和list=[]有什麼差異？我一開始以為是一樣的結果，直到執行了下面的程式**

**更新：我知道為什麼了，請直接到更新區看**

```python
m = []
n = []
file_path = "hw1_15_train.dat"
with open(file_path) as f :
	#切成一行一行
	for line in f :
		#實做m.append([float(i) for i in line.split()])的囉唆改寫：
		for i in line.split():
			n.append(i)
		m.append(n)
		del n[:]#這樣寫雖然不會把整個n刪掉，但發現m變成空的

for i in m:
	print(i)
```
後記
--------------
這是我再幫別人的PLA演算法寫註解時發現的，因為對m.append([float(i) for i in line.split()])這行很不理解，再試著用比較囉嗦的寫法改寫後偶然發現的
原本我是寫n=[]，但突然想到del，就想說可不可以用del的方式來做，查完del的說明後，寫下del n[:]，原以為這樣也可以，沒想到印出m時，全部都是空的[]

目前狀況
-------------
已解決，請看更新區

更新區
======================
後來，我就直接放棄這個問題，跑去找list[:]的解釋，偶然間就看到有個list的function：clear()，功能跟del list[:]是一樣的；就姑且一試，當然，m裡面都是[]，突然間，我想起做rpg時為了知道物件變數傳到哪時寫了print(物件變數)，然後會出現該物件在哪個記憶體位址；我就去找如何顯示物件的記憶體位址，找到了id()
便做了以下測試：

在使用n=[]時並顯示n的位址
-----------------------------
```python
...以上一樣同原完整程式碼
	for i in line.split():
		n.append(i)
	m.append(n)
	print("n.clear()前:",str(id(n)))
	#指派新的記憶體位址給n
	#n=[]
	#清除的是同一個記憶體位址的n
	n.clear()
	#del n[:]
	print("n.clear()後：",str(id(n)))
	print("--------------\n")
...以下一樣同原完整程式碼
```
得到結果
-----------------

最一開始的n: 90504608

n=[]前: 90504608

n=[]後： 90504808

____________________

n=[]前: 90504808

n=[]後： 90504568

____________________

n=[]前: 90504568

n=[]後： 90505048

____________________

n=[]前: 90505048

n=[]後： 90554856

____________________

n=[]前: 90554856

n=[]後： 90554936

____________________

n=[]前: 90554936

n=[]後： 90554976

____________________

['0.97681', '0.10723', '0.64385', '0.29556', '1'] 90504608

['0.67194', '0.2418', '0.83075', '0.42741', '1'] 90504808

['0.20619', '0.23321', '0.81004', '0.98691', '1'] 90504568

['0.51583', '0.055814', '0.92274', '0.75797', '1'] 90505048

['0.70893', '0.10836', '0.33951', '0.77058', '1'] 90554856

[] 90554936
......

在使用n.clear()時並顯示n的位址
-----------------------------
```python
...以上一樣同原完整程式碼
	for i in line.split():
		n.append(i)
	m.append(n)
	print(id(n))
	#指派新的記憶體位址給n
	#n=[]
	#清除的是同一個記憶體位址的n
	n.clear()
	#del n[:]
	print(id(n))
	print("--------------\n")
...以下一樣同原完整程式碼
```
得到結果
-----------------

最一開始的n: 85523832

n.clear()前: 85523832

n.clear()後： 85523832

____________________

n.clear()前: 85523832

n.clear()後： 85523832

____________________

n.clear()前: 85523832

n.clear()後： 85523832

____________________


n.clear()前: 85523832

n.clear()後： 85523832

____________________

n.clear()前: 85523832

n.clear()後： 85523832

____________________

n.clear()前: 85523832

n.clear()後： 85523832

____________________

[] 85523832

[] 85523832

[] 85523832

[] 85523832

[] 85523832

[] 85523832
.......

總結
--------------
因為我不曉得放在m裡面的東西還是跟n有關，看來寫程式我要學的可多了(話說C語言會不會也有一樣的特性?，學著學著就忘了C...)



原完整程式碼
-------------
```python
"""不知道為什麼，del n[:]會讓m的值裡面變成[]，但n=[]的話，就不會影響到m"""

m = []
n = []
print("最一開始的n:",str(id(n)))
file_path = "hw1_15_train.dat"
with open(file_path) as f :
	#切成一行一行
	for line in f :
		#寫法一
		#m.append([float(i) for i in line.split()])

		"""結果：[0.99279, 0.15139, 0.27982, 0.45122, 1.0]...
		我猜，是因為[]的關係，會自動把i放進[]，再給m儲存"""

    #寫法二
       #實做m.append([float(i) for i in line.split()])的失敗囉嗦改寫
        """for i in line.split():
        m.append(float(i))"""
        #這種寫法會變成0.99279，0.15139, 0.27982, 0.45122, 1.0
        #因為line.split就會把line給一個一個切開，m.append就會一個一個i存
      
		#實做m.append([float(i) for i in line.split()])的成功囉唆改寫：
		for i in line.split():
		 n.append(i)
		m.append(n)
		
		#del n[:]#這樣寫才不會把整個n刪掉，但發現m變成空的
		
		n = []#覺得這寫法太遜，改用上面的，但上面的會讓m是空的，這個就不會

for i in m:
	print(i)
```

[參考網址： del 陳述式](https://docs.python.org.tw/3/tutorial/datastructures.html)
